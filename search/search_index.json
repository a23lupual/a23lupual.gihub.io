{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SERVIDOR NGINX","text":""},{"location":"#1-instalacion-serevidor-web-nginx","title":"1. Instalaci\u00f3n serevidor web Nginx","text":"<p>Primero deberemos de actualizar los repositorios de nuestra m\u00e1quina debian.</p> <p>Esto se hace con el siguiente comando</p> <p><code>sudo apt update</code></p> <p>Y posteriormente tendremos que intalar nginx:</p> <p><code>sudo apt install nginx</code></p> <p>Para comprobar que la instalaci\u00f3n se ha hecho de forma correcta y el servidor est\u00e1 activo introduciremos el siguiente comando</p> <p></p> <p>Y si vemos que el estado del servidor es <code>runing</code> es que la instalaci\u00f3n se ha hecho de forma correcta.</p>"},{"location":"#2-creacion-de-las-carpetas-del-sitio-web","title":"2. Creacion de las carpetas del sitio web","text":"<p>Todos los archivos que se almacenen en nginx se almacenar\u00e1n en un sistema de carpetas. Todas estas se encontrar\u00e1n en /var/www/; para esto vamos a crear una carpeta para nuestra web aqu\u00ed.</p> <p><code>sudo mkdir -p /var/www/nombre_web/html</code></p> <p>El nombre del dominio lo puedes elegir y dentro de la carpeta html tendr\u00e1s que clonar el repositorio <code>https://github.com/cloudacademy/static-website-example</code> que ser\u00e1 una p\u00e1gina web de prueba para comprobar que funciona correctamente.</p> <p></p> <p>Adem\u00e1s tendremos que cambiar los permisos para que el servidor pueda acceder a dicha carpeta para mostrarla.</p> <p>Para cambiar el propietario:</p> <p><code>sudo chown -R www-data:www-data /var/www/nombre_web/html</code></p> <p>Y para cambiar los permisos:</p> <p><code>sudo chmod -R 755 /var/ww/nombre_web</code></p> <p>Si hemos hecho estos cambios al hacer <code>ls -la</code> deberia aparecer la carpeta con las siguientes propiedades:</p> <p></p> <p>Para comprobar que el servidor est\u00e1 funcionando introducimos en la m\u00e1quina anfitriona <code>http://IP-maq-virtual</code> Esto lo sabremos con el comando <code>ip a</code>.</p> <p>Deberiamos de ver algo asi:</p> <p></p>"},{"location":"#2-comprobaciones-de-servidor-web-nginx","title":"2. Comprobaciones de servidor web NGINX","text":"<p>Hay dos rutas importantes una es <code>sites-available</code>, que contiene las rutas de los archivos de configuraci\u00f3n de los hosts virtuales, decir todas las webs que alberga el servidor. La otra es <code>sites-enable</code> que contiene los archivos de los sitios habilitados. Dentro de esta se encuentra el archivo <code>default</code> la cual muestra la p\u00e1gina abierta anteriormente.</p> <p>Para que se muestre en contenido de nuestra web debemos modificar el archivo <code>/etc/nginx/sites-availables/nombre_web</code>. Con el comando:</p> <p><code>sudo nano /etc/nginx/sites-availables/vuestro_dominio</code></p> <p>E introducimos el siguiente bloque:</p> <p></p> <p>La ruta debe ser donde se encuentre el archivo index.html</p> <p>Y creamos un enlace simbolico entre este archivo y el de los sitios que estan habilitados:</p> <p><code>sudo ln -s /etc/nginx/sites-available/nombre_web /etc/nginx/sites-enable</code></p> <p>Y reiniciamos el servidor </p> <p><code>sudo systemctl restart nginx</code></p>"},{"location":"#3-comprobaciones","title":"3. Comprobaciones","text":"<p>Como no poseemos un servidor DNS en el archivo <code>/etc/hosts</code> a\u00f1adimos la l\u00ednea <code>192.168.X.X nombre_web</code>.</p>"},{"location":"#4-ftp","title":"4. FTP","text":""},{"location":"#como-transferir-archivos-desde-nuestra-maquina-localanfitrion-a-nuestra-maquina-virtual-debianservidor-remoto","title":"\u00bfComo transferir archivos desde nuestra m\u00e1quina local/anfitrion a nuestra m\u00e1quina virtual Debian/servidor remoto?","text":"<p>Principalmente hay dos m\u00e9todos para hacer esta trasferencia de datos y archivos el m\u00e1s f\u00e1cil que va a ser a trav\u00e9s de git y la otra es mediante el protocolo FTP.     El protocolo FTP no es seguro ya que la informaci\u00f3n no viaja de forma cifrada, pero en 2001 se introdujo el SFTP que la aplica una capa ssh al FTP.</p>"},{"location":"#configurar-servidor-sftp-debian","title":"Configurar servidor SFTP DEBIAN","text":"<p>Primero lo instalamos:</p> <p><code>sudo apt-get update</code> <code>sudo apt-get intall vsftpd</code></p> <p>Ahora en el home creamos una carpeta llamada <code>/home/nombre_usuario/ftp</code></p> <p>Configuramos vsftpd para que este sea el directorio al cual vstpd cambia despues de conectarse.</p> <p>Creamos los certificados para conectarnos:</p> <p></p> <p>En el siguiente archivo :</p> <p><code>sudo nano /etc/vsftpd.conf</code></p> <p>Borramos las siguientes l\u00edneas</p> <p><code>rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</code></p> <p><code>rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</code></p> <p><code>ssl_enable=NO</code></p> <p>Y a\u00f1adimos las siguientes</p> <p></p> <p>Por \u00faltimo usamos un cliente FTP como Filezilla para acceder a los archivos de nuestro servido nginx.</p> <p></p> <p>En el recuadro servidor introducimos la ip de la m\u00e1quina debian, el nomber de usuario de la m\u00e1quina la contrase\u00f1a y el puerto que usaremos el 21.</p>"},{"location":"#1-cuestion-1","title":"1. Cuestion 1","text":"<p>Al no enlazar <code>sites-available</code> y <code>sites-enabled</code> mi p\u00e1gina web no aparecer\u00e1 como activa o enabled</p>"},{"location":"#2-cuestion-2","title":"2. Cuestion 2","text":"<p>Que nignx no tendr\u00e1 permisos para poder mostrar los archivos que haya dentro.</p>"},{"location":"tarea2.2/","title":"Pr\u00e1ctica 2.2 \u2013 Autenticaci\u00f3n en Nginx","text":""},{"location":"tarea2.2/#introduccion","title":"Introducci\u00f3n","text":""},{"location":"tarea2.3/","title":"PROXY INVERSO CON NGINX","text":""},{"location":"tarea2.3/#1-que-es-un-servidor-proxy","title":"1. \u00bfQu\u00e9 es un servidor Proxy?","text":"<p>Un servidor Proxy es un intermediario entre el cliente y el servidor en ser un Proxy inverso, o un intermediario entre un servidor y el cliente siendo este un Proxy de reenv\u00edo.</p>"},{"location":"tarea2.3/#12-beneficios-de-un-servidor-proxy-inverso","title":"1.2. Beneficios de un servidor Proxy inverso","text":"<p>Un servidor Proxy nos va a aportar multitud de beneficios:</p> <ul> <li> <p>Con el podemos evitar restricciones de navegaci\u00f3n estatales o institucionales: Hay ciertas instituciones o estados que no les interesa que accedamos a ciertos sitios de la red, nosotros al usar un servidor proxy y salir a la red a trav\u00e9s de el podremos sortear dichas limitaciones.</p> </li> <li> <p>Bloquear acceso a ciertos sitios: De la misma forma dichas instituciones y estados usan dichos servidores para bloquear el acceso a distintos sitios, mediante filtros de contenido.</p> </li> <li> <p>Para proteger tu identidad en l\u00ednea: Al colocar un servidor Proxy entre tu y la red, no sales a esta misma directamente si no a trav\u00e9s del servidor; ya que al acceder a cualquier sitio web se har\u00e1 con la direcci\u00f3n IP del servidor.</p> </li> </ul>"},{"location":"tarea2.3/#13-beneficios-de-un-servidor-proxy-inverso","title":"1.3. Beneficios de un servidor Proxy inverso","text":"<p>Como hemos dicho este es el servidor que se encuentra antes del servidor que desea conectarse el cliente.</p> <ul> <li> <p>Balanceo de Carga: Si un sitio web recibe muchas peticiones este puede redireccionar peticiones y varios Proxys encargarse de entregar dichas peticiones.</p> </li> <li> <p>Protecci\u00f3n contra ataques: Al igual que anteriormente el servidor o servicio no se mostrar\u00e1 a la red con su direcci\u00f3n IP si no que lo har\u00e1 a trav\u00e9s de la direcci\u00f3n IP del servidor Proxy que lo precede, lo que dificultar\u00e1 un ataque directo al mismo.</p> </li> <li> <p>Almacenamiento en cach\u00e9: Si un recurso es muy usado no har\u00e1 que un cliente acceda directamente al servidor ya que el Proxy podr\u00e1 almacenar dicho recurso para poder aumentar el rendimiento.</p> </li> <li> <p>Cifrado SSL: El servidor Proxy tambi\u00e9n se puede configurar para el cifrado y descifrado de la informaci\u00f3n de cada cliente, esto ayuda a aliviar carga del servidor origen.</p> </li> </ul>"},{"location":"tarea2.3/#2-configuracion-del-servidor","title":"2. CONFIGURACI\u00d3N DEL SERVIDOR","text":"<p>Para poder hacer esto necesitaremos tener dos Servidores Debian, por eso necesitaremos clonar el servidor original; uno de estos se encargar\u00e1 de mostrar los recursos y el otro har\u00e1 las veces de Proxy.</p> <p>Ahora en vez de hacer las peticiones al servidor original haremos estas al servidor proxy el cual nos redigir\u00e1 al servidor.</p>"},{"location":"tarea2.3/#21-primero-necesitaremos-cambiar-el-nombre-de-la-web-por-el-de-webserver","title":"2.1. Primero necesitaremos cambiar el nombre de la web por el de webserver","text":"<p>Esto implica:</p> <ol> <li> <p>Cambiar el nombre del archivo de configuraci\u00f3n de sitios disponibles para Nginx </p> <ul> <li> <p>Cambiar el nombre del sitio web dentreo de este archivo de configuracion </p> </li> <li> <p>Y borrar el link simb\u00f3lico de la carpeta sites-enabled </p> </li> </ul> </li> <li> <p>En el archivo de configuraci\u00f3n del sitio web, en lugar de hacer que escuche al puerto 80 que escuche al 8080.</p> </li> <li> <p>Reiniciar Nginx.</p> </li> </ol>"},{"location":"tarea2.3/#nginx-proxy-inverso","title":"Nginx proxy inverso","text":"<p>Ahora cuando queramos acceder a <code>http://ejemplo-proxy</code>, nos reenviar\u00e1 a <code>http://webserver:8080</code> para esto tendermos que:</p> <ul> <li> <p>Crear un archivo de configuraci\u00f3n en <code>sites-available</code> con el nombre <code>ejemplo-proxy</code></p> </li> <li> <p>Este tendr\u00e1 la siguiente configuraci\u00f3n.</p> </li> </ul> <p></p> <ul> <li>Pondremos que escuche al puerto 80.</li> <li>El nombre que le hayamos puesto al servidor</li> <li>Y la directiva <code>prox_pass</code> ser\u00e1 el lugar al que nos redigir\u00e1 en el que habr\u00e1 que poner <code>http://IP_server:puerto</code>.</li> <li>Crear un enlace simbolico del archivo de configuraci\u00f3n <code>webserver-proxy</code> en <code>sites-enabled</code>. </li> </ul>"},{"location":"tarea2.3/#3-ccomprobaciones","title":"3. CCOMPROBACIONES","text":"<ul> <li>Comprobad adem\u00e1s la petici\u00f3n y respuesta con las herramientas de desarrollador de Firefox en Xubuntu. Pulsando F12 en el navegador os aparecer\u00e1n estas herramientas</li> </ul>"},{"location":"tarea2.3/#anadiendo-cabeceras","title":"A\u00d1ADIENDO CABECERAS","text":"<p>Para comprobar donde se conecta crearemos una cabecera con el nombre del Host, esto lo haremso a\u00f1adiendo <code>add_header Host nombre_del_host;</code> esto lo haremos dentro del archivo de configuraci\u00f3n en la parte <code>location / {...}</code>.</p>"},{"location":"tarea2.4/","title":"BALANCEO DE CARGA CON PROXY INVERSO EN NGINX","text":""},{"location":"tarea2.4/#1-introduccion","title":"1. INTRODUCCION","text":"<p>Para entender esta pr\u00e1ctica primero debemos saber que es un proxy inverso y un balanceador de carga:</p>"},{"location":"tarea2.4/#11-proxy-inverso","title":"1.1 Proxy inverso","text":"<p>Un proxy inverso es un tipo de servidor que se encuentra entre el cliente y servidor y se encarga de recibir las peticiones y redireccionarlas al servidor web, para despues responder dicha solicitud.</p>"},{"location":"tarea2.4/#12-balanceador-de-carga","title":"1.2 Balanceador de carga","text":"<p>Un balanceador de carga, es un tipo de proxy inverso que adem\u00e1s se encarga de distribuir las peticiones entre servidores para que as\u00ed un solo servidor no se tenga que encargar de todas las solicitudees. Esto es necesario cuando un sitio necesita de varios servidores por la cantidad de peticiones que reciba o por la disposici\u00f3n geogr\u00e1fica del mismo; esta implementaci\u00f3n aporta un nivel mayor de seguridad ya que al haber dos servidores dando las mismas respuestas, si uno cae ya sea por un ataque o por cualquier otro problema tendremos el otro resolviendo las peticiones mientras este est\u00e9 caido. Y por \u00faltimo esto tambi\u00e9n mejora la experiencia del usuario ya que reduce la cantidad de errores percibidas por el usuario, detectando un servidor defectuoso y redireccionando las peticones a otro, y por otra parte reduciendo la velocidad de respuesta. </p>"},{"location":"tarea2.4/#2-tarea","title":"2. TAREA","text":"<p>Para esta pr\u00e1ctica vamos a necesitar el proxy inverso de la pr\u00e1ctica anteior, y replicar el servidor web que teniamos.</p> <ul> <li>Cada servidor web tendr\u00e1 un sitio web espec\u00edfico para esta practica.<ul> <li>El webserver2 tendr\u00e1 un IP asignada de forma fija mediante la configuraci\u00f3n DHCP.</li> </ul> </li> <li>Cambiaremos la configuraci\u00f3n del proxy inverso para que tambi\u00e9n haga el balanceo de carga.</li> <li>Haremos las peticiones HTTP desde el navegador WEB de nuestra m\u00e1quina anfitriona, accediendo a <code>http://balanceo</code>.</li> </ul>"},{"location":"tarea2.4/#3-configuraciones","title":"3. CONFIGURACIONES","text":"<p>Primero necesitamos desenlazar la carpeta con la web que teniamos previamente <code>/etc/nginx/sites-enabled</code> y ejecutar <code>unlink nombre-archivo</code>.</p>"},{"location":"tarea2.5/","title":"Practica 2.5 - Proxy inverso y balanceo de carga con SSL en NGINX","text":""},{"location":"tarea2.5/#introduccion","title":"Introducci\u00f3n","text":"<p>Teniendo en cuenta en el escenario en el que nos encontramos, ahora mismo los propios servidores web lo cual aumenta la carga que tienen que tienen que soportar, para esto vamos a trasladar el cifrado el servidor proxy, se puede pensar que la comunicaci\u00f3n entre el proxy y el servidor web puede ser insegura, pero esta comunicaci\u00f3n se lleva a cabo en una red privada, lo cual la protege de cualquier ataque.</p>"},{"location":"tarea2.5/#certificados","title":"Certificados","text":"<p>HTTPS se basa en el uso de certificados digitales, que resumiendo al entrar en una web se nos entrega un certificado mostrando quien es la p\u00e1gina. Para comprobar dichos certificados deberemos acceder a la Autoridad de Certificaci\u00f3n (CA). Los navegadores tienen precargadas las Autoridades de certificaci\u00f3n en las que conf\u00edan, por lo tanto si una web usa una diferentes a estas nos aparecer\u00e1 un error diciendo que esta p\u00e1gina no es segura.</p>"},{"location":"tarea3.1/","title":"PRACTICA 3.1.- INSTALACI\u00d3N DE TOMCAT Y MAVEN PARA DESPLIEGUE DE APLICACI\u00d3N JAVA","text":""},{"location":"tarea3.1/#1-introduccion","title":"1. INTRODUCCI\u00d3N","text":"<p>Para esta pr\u00e1ctica necesitaremos una m\u00e1quina virtual debian a poder ser con entorno gr\u00e1fico en mi caso  usar\u00e9 una m\u00e1quina Debian 12.</p> <p>Una vez tengamos esta instalada y corriendo nos dispondremos a instalar tomcat que usaremos la versi\u00f3n 10 de tomcat.</p>"},{"location":"tarea3.1/#2-instalacion","title":"2. INSTALACI\u00d3N","text":"<p>Para la instalaci\u00f3n de tomcat necesitaremos herramientas del sistema de los repositorios Debian y para esto actualizaremos los paquetes:</p> <ul> <li>Primero necesitaremos actualizar el sistema</li> </ul> <p></p> <ul> <li>Despues instalar los paquetes que vamos a necesitar</li> </ul> <p></p> <p>Continuamos con la instalaci\u00f3n de tomcat con el siguiente comando:</p> <p></p> <p>Tambi\u00e9n podemos instalar esto mismo desde la p\u00e1gina de tomcat instalaci\u00f3n tomcat.</p>"},{"location":"tarea3.1/#21-creacion-del-servicio-tomcat","title":"2.1 Creacion del servicio tomcat","text":"<p>Para que podamos usar tomcat como un servicio deberemos comenzar con la creaci\u00f3n de usuario la cual usar\u00e1 este.</p> <p></p> <p>Una vez que hemos creado este usuario debemos descomprimir lo que hemos instalado previamente en el directorio que le hemos asignado a tomcat en nuestro caso <code>/opt/tomcat</code>.</p> <p></p> <p>Cuando tenemos el paso anterior debemos darle a esta carpeta los permisos al usuarios que hemos creado para tomcat con la siguiente l\u00ednea.</p> <p></p> <p>Para facilitar la instalaci\u00f3n y mantenimiento podemos cambiar el nombre de estos paquetes con el siguiente comando <code>mv &lt;/direccion/nombre-antiguio&gt; &lt;/direccion/nombre-nuevo&gt;</code>.</p> <p>Creamos el archivo de unidad de Systemd:</p> <p></p> <p>Y en este mismo archivo escribiremos los siguiente:</p> <p></p> <p>Si lo hemos hecho todo bien iniciaremos el servicio <code>sudo systemctl start tomcat10</code></p> <p>Si nos vamos al navegador y buscamos lo siguiente <code>http://localhost:8080</code> nos deber\u00eda aparecer una p\u00e1gina como esta</p>"},{"location":"tarea3.1/#3-firewall","title":"3. FIREWALL","text":"<p>Si tenemos un firewall UFW en el sistema y queremos acceder desde la red tendremos que a\u00f1adir una regla al puerto 8080/TCP</p> <p><code>sudo ufw allow 8080/tcp</code></p>"},{"location":"tarea3.1/#4-configuracion-del-sistema-de-administracion-de-tomcat","title":"4. Configuraci\u00f3n del sistema de administraci\u00f3n de tomcat","text":"<p>Para esto comenzamos introduciendo el siguiente comando</p> <p></p> <p>Accedemos al archivo <code>/opt/tomcat/apache-tomcat/conf/tomcat-users.xml</code> y a\u00f1adimos las siguienes l\u00edneas</p> <p></p> <p>Para esta pr\u00e1ctica usaremos el usuario \"usuario\" y de contrase\u00f1a \"usuario\"</p> <p>Ahora buscaremos <code>http://localhost:8080/admin</code> y si lo hemos hecho bien nos pedir\u00e1 que nos autenticamos</p> <p></p> <p>Y veremos la p\u00e1gina de admin</p> <p></p> <p>Por \u00faltimo desplegaremos una aplicaci\u00f3n <code>.war</code> desde la p\u00e1gina <code>http://localhost:8080/manager</code> la desplegaremos desde aqu\u00ed</p> <p></p> <p>Aqu\u00ed eligiremos el archivo <code>.war</code> y una vez despleado podremos acceder como un archivo normal</p> <p></p>"},{"location":"tarea3.1/#5-despliege-con-maven","title":"5. Despliege con MAVEN","text":"<ol> <li> <p>Para hacer un despliegue con Maven primero actualizaremos los repositorios con <code>sudo apt update</code> e intalaremso wget <code>sudo apt install wget -y</code></p> </li> <li> <p>Instalamos Apache Maven </p> </li> </ol> <p></p> <p>Para poder usar maven con tomcat tenemos que asegurarnos que a\u00f1adimos todos los usuarios necesarios para que maven pueda hacer este despliege esto significa que maven tenga el permiso de <code>manager-script</code>; para esto a\u00f1adimos las siguientes l\u00edneas.</p> <pre><code>&lt;role rolename=\"admin\"/&gt;\n&lt;role rolename=\"admin-gui\"/&gt;\n&lt;role rolename=\"manager\"/&gt;\n&lt;role rolename=\"manager-gui\"/&gt;\n&lt;role rolename=\"manager-script\"/&gt;\n&lt;user username=\"admin\" password=\"admin\" roles=\"admin,admin-gui,manager,manager-gui\"/&gt;\n&lt;user username=\"manager\" password=\"manager\" roles=\"manager-script\"/&gt;\n</code></pre> <p>Una vez configurado el archivo setting.xml de tomcat debemos configurar el archivo <code>/etc/maven/settings.xml</code> donde a\u00f1adiremos las siguiente l\u00edneas </p> <p></p>"},{"location":"tarea3.1/#6-despliegue","title":"6. despliegue","text":"<p>Ahora para probar que hemos configurado todo bien, vamos a probar a desplegar una aplicaci\u00f3n Java de prueba, para ver si podemos desplegarla sobre la arquitectura, lo haremos con el siguiente comando:</p> <p></p> <p>P</p>"},{"location":"tarea3.2/","title":"Practica 3.2: Despliegue de aplicaciones con Node Express","text":""},{"location":"tarea3.2/#introduccion","title":"Introducci\u00f3n","text":"<p>Vamos a realizar el despligue de una aplicaci\u00f3n Node.js, la diferencia que la aplicaci\u00f3n no se despliega sobre un servidor si no que la aplicaci\u00f3n es el servidor</p>"},{"location":"tarea3.2/#instalacion-de-nodejs-express-y-test-de-la-primera-aplicacion","title":"Instalaci\u00f3n de Node.js, Express y test de la primera aplicaci\u00f3n","text":"<p>Antes debemos comprobar que el servidor tomcat est\u00e1 apagado; primero comprobamos el estado con el comando <code>sudo systemctl status tomcat10</code> y si el estado es runnig lo paramos de la siguiente manera <code>sudo systemctl stop tomcat10</code>.</p> <p>Primero comprobamos que los paquetes est\u00e1n actualizados con <code>sudo apt update</code> y <code>sudo apt upgrade</code>. Seguidamente a\u00f1adimos la rama 16.x a la rama del repositorio de Node.js</p> <p></p> <p>Y despues simplemente instalamos Node.js con el siguiente comando</p> <p></p>"},{"location":"tarea3.2/#instalacion-de-expressjs","title":"Instalaci\u00f3n de ExpressJS","text":"<p>Ahora instalamos Express.js y para hacerlo de forma global introducimos el siguiente comando</p> <p></p> <p>Con esta serie de comandos crearemos un archivo e inicializaremos un proyecto Node.js con express.js</p> <p></p> <p>Creamos el fichero <code>app.js</code> e introducimos el siguiente c\u00f3digo de javaScript</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) =&gt; {\n    res.send('Hello. Welcome to this blog')\n})\n\napp.listen(port, () =&gt; {\n    console.log(`Example app listening at http://localhost:${port}`)\n})\n</code></pre> <p>Y por \u00faltimo para comprobar la correcta instalaci\u00f3n iniciamos el servidor con <code>node app.js</code> y deberiamos ver algo as\u00ed:</p> <p></p> <p>Tambi\u00e9n tenemos que poder acceder a este servidor desde nuestra m\u00e1uqina local con <code>http://ip-maqina:3000</code></p>"},{"location":"tarea3.2/#despliegue-de-una-nueva-aplicacion","title":"Despliegue de una nueva aplicacion","text":"<p>Para practicar el despliegue de aplicaciones de terceros lo haremos de una aplicaci\u00f3n de un repositorio github.</p> <p>Primero clonamos dicho repositorio</p> <p><code>git clone https://github.com/MehedilslamRipon/Shopping-Cart-Application</code></p> <p></p> <p>Instalamos npm en este proyecto <code>npm install</code>, e iniciamos la aplicaion <code>npm run start</code>:</p> <p>Nos aparecer\u00e1 el siguiente error <code>sh: 1: nodemon: not found</code> y esto es porque no teneos instalado nodemon de forma local en el proyecto y con </p> <p></p> <p>Y con esto ya deberia funcionar nuestro proyecto</p> <p></p>"},{"location":"tarea3.2/#cuestiones","title":"Cuestiones","text":"<p>Cuando ejecut\u00e1is el comando npm run start, lo que est\u00e1is haciendo es ejecutar un script:</p> <ul> <li> <p>\u00bfDonde podemos ver que script se est\u00e1 ejecutando? El script que se ejecuta con npm run start est\u00e1 definido en el archivo package.json del proyecto, dentro de la secci\u00f3n \"scripts\"</p> </li> <li> <p>\u00bfQu\u00e9 comando est\u00e1 ejecutando?</p> </li> </ul> <p>El comando que se ejecuta es el valor que se encuentra en la secci\u00f3n \"start\" dentro del objeto \"scripts\" en package.json.</p>"},{"location":"tarea3.4/","title":"Practica 3.4: Despliegue de una aplicacion React en Netlify","text":""},{"location":"tarea3.4/#introduccion","title":"Introducci\u00f3n","text":"<p>En la practica anterior hemos desplegado, una aplicaci\u00f3n en local para el desarrollo de la misma, pero en esta simularemos una situaci\u00f3n m\u00e1s real en la que desplegamos una aplicaci\u00f3n para producci\u00f3n, esto se puede hacer de dos maneras, copiando los archivos que teniamos en el servidor local y pegandolos en el hosting, o por otra parte, podemos usar GitHub mediante que har\u00e1 esta trasmisi\u00f3n mediante ssh y una plataforma PaaS (Plataform as a Service) como Netlify para el despliegue a producci\u00f3n de una aplicaci\u00f3n.</p>"},{"location":"tarea3.4/#que-es-github","title":"\u00bfQ\u00fae es GitHub?","text":"<p>GitHub es un servicio basado en la nube que aloja un sistema de control de versiones llamado Git. El cual permite subir cambios a los desarrolladores, a la vez que mantiene un seguimiento del progreso.</p> <p>El control de versiones permite seguir un rastreo de los cambios que se realizan y ante un error, permite revertirlos para que no lleguen a producci\u00f3n.</p>"},{"location":"tarea3.4/#que-es-netlify","title":"\u00bfQu\u00e9 es Netlify?","text":"<p>Netligy es un proveedor de alojamiento en la nube que proporciona el backend sin servidores para sitios est\u00e1ticos. Est\u00e1 dise\u00f1ado para buscar la productividad en el frontend, para producir y probar rapidamente sitios web.</p> <p>Funciona conect\u00e1ndose a un repositorio de GitHub, para descargar el c\u00f3gigo fuente para la configuraci\u00f3n del sitio, y poder prerenderizar los archivos del sitio.</p> <p>Ventajas de Netlify:</p> <ul> <li>Hace que el despliegue sea muy sencillo con GitHub, GitLab o Bitbucket.</li> <li>Incorpora un servicio DNS.</li> <li>Podemos desplegar una sola rama, o probar otras con un Pull Request para ver el efecto en el sitio.</li> <li>Permite la previsualizaci\u00f3n.</li> <li>Permite el envio de formulaios para recoger informaci\u00f3n de los usuarios.</li> </ul>"},{"location":"tarea3.4/#creacion-de-nuestra-aplicacion","title":"Creaci\u00f3n de nuestra aplicacion","text":"<p>Para crear nuestra aplicaci\u00f3n estableceremos una conexion 'ssh' con nuestra m\u00e1quina debian para crear un directorio en el que alojaremos la aplicaci\u00f3n.</p> <p></p> <p>Dentro de este directorio crearemos tres archivos dos <code>.html</code> y un <code>.js</code> los que conformar\u00e1n nuestra aplicaci\u00f3n de ejemplo.</p>"},{"location":"tarea3.4/#headhtml","title":"head.html","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n        &lt;title&gt;Hola Mundo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n        &lt;h1&gt;Esta es la pagina principal&lt;/h1&gt;\n\n&lt;p&gt;&lt;a href=\"/tailPage\"&gt;Ir a la siguiente pagina&lt;/a&gt;&lt;/p&gt;\n\n\n&lt;/body&gt;\n</code></pre>"},{"location":"tarea3.4/#tailhtml","title":"tail.html","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n        &lt;title&gt;Hola Mundo&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;h1&gt;FUNCIONA&lt;/h1&gt;\n\n&lt;/body&gt;\n</code></pre>"},{"location":"tarea3.4/#aplicacionjs","title":"aplicacion.js","text":"<pre><code>var http = require('http');\nvar fs = require('fs'); // para obtener los datos del archivo html\nvar port = process.env.PORT || 8080; \n\nhttp.createServer(function (req, res) {\n    res.writeHead(200, { 'Content-Type': 'text/html' });\n\n    // req.url almacena el path o ruta de la URL\n    var url = req.url;\n    if (url === \"/\") {\n// fs.readFile busca el archivo HTML\n// el primer par\u00e1metro es el path al archivo HTML\n// y el segundo es el callback de la funci\u00f3n\n// si el archivo no se encuentra, la funci\u00f3n devuelve un error\n// si el archivo se encuentra, el contenido del mismo se encuentra en pgres    \n        fs.readFile(\"head.html\", function (err, pgres) {\n            if (err)\n                res.write(\"HEAD.HTML NOT FOUND\");\n            else {\n                // Las siguientes 3 lineas\n                // tienen la funci\u00f3n de enviar el archivo html\n                // y finalizar el proceso de respuesta\n                res.writeHead(200, { 'Content-Type': 'text/html' });\n                res.write(pgres);\n                res.end();\n            }\n        });\n    }\n    else if (url === \"/tailPage\") {\n        fs.readFile(\"tail.html\", function (err, pgres) {\n            if (err)\n                res.write(\"TAIL.HTML NOT FOUND\");\n            else {\n                res.writeHead(200, { 'Content-Type': 'text/html' });\n                res.write(pgres);\n                res.end();\n            }\n        });\n    }\n\n}).listen(port, function () {\n    console.log(\"SERVER STARTED PORT: 8080\");\n});\n</code></pre> <p>Igual que antes para crear nuestro servidor Node.js hacemos <code>npm init</code> para crear el archivo <code>package.json</code>.</p> <p></p> <p>Podemos comprobar el correcto funcionamiento con <code>node aplicacion.js</code></p> <p></p> <p>De esta manera sabemos que nuestra aplicaci\u00f3n funciona perfectamente y la podemos desplegar en sitios como AWS, GCP, Azure, Digital Ocean, Heroku...</p> <p>DISCLAIMER\u00a1\u00a1\u00a1\u00a1 Para que nos funcione el Paas debemos hacer cambios dentro de el borrando todo lo que haya en el bloque de scripts y solamente dejar <code>\"start\":\"node aplicacion.js\"</code></p> <p></p>"},{"location":"tarea3.4/#proceso-de-despliegue-en-netlify","title":"Proceso de despliegue en Netlify","text":"<p>Para la aplicaci\u00f3n de Netlify clonaremos el siguiente repositorio <code>https://github.com/StackAbuse/color-shades-generato</code>, el despliegue se realizar\u00e1 de dos maneras:</p> <ul> <li> <p>Mediante el CLI de Netligy, es decir desde la terminal, desde un directorio local de nuestra m\u00e1quina.</p> </li> <li> <p>Mediante un c\u00f3digo publicado en un repositorio de GitHub.</p> </li> </ul>"},{"location":"tarea3.4/#despliegue-mediante-cli","title":"Despliegue mediante CLI","text":"<p>Primero deberemos de instalar el CLI de Netlify </p> <p></p> <p>Despues debemos autenticarnos que se har\u00e1 con el siguiente comando : <code>netlify login</code> En este punto tendremos que tener la aplicaci\u00f3n descargada, y estar logeados con Netlify, lo siguiente ser\u00e1 preparar la aplicaci\u00f3n para el despliegue.</p> <p>Comenzamos instalando el <code>package.json</code> en el directorio de la aplicacion con el comando <code>npm install</code>, posteriormente realizamos el build con <code>npm run build</code>:</p> <p></p> <p>Una vez lo hemos instalado introducimos el comando <code>netlify deploy</code> el cual nos har\u00e1 algunas preguntas las cuales dejaremos por defecto.</p> <p></p> <p>Y si todo ha ido correctamente nos saldr\u00e1 el siguiente mensaje <code>If everything looks good on your draft URL, deploy it to your main site URL with the --prod flag. netlify deploy --prod</code></p> <p></p>"},{"location":"tarea3.4/#despliegue-mediante-conexion-con-github","title":"Despliegue mediante conexi\u00f3n con GitHub","text":"<p>Primero borraremos el site que hemos subido antes para evitar problemas</p> <p></p> <p>Y tambi\u00e9n eliminaremos el directorio que hemos creado antes <code>rm -rf directorio_repositorio</code> </p> <p>Esta vez nos vamso a descargar la aplicaci\u00f3n con <code>wget</code> para que as\u00ed no tenga ninguna relaci\u00f3n con GitHub.</p> <p>Una vez nos hemos descargado el .zip creamos una carpera nueva y descomprimos el archivo.</p> <p></p> <p>Tras esto inicializamos un repositorio git en el directorio que hayamos creado con el .zip.</p> <p></p> <p>Y solo nos queda hacer un push al repositorio que hemos creado antes para subir el contenido del commit</p> <p></p> <p>Con esto ya hemos subido a GitHub nuestra aplicaci\u00f3n, el siguiente paso que nos queda es entrar en nuestro dashboard de Netlify para enlazar el repositorio de github con Netlify para poder hacer el despliegue.</p> <p>Comenzamos importando como un proyecto existente en github</p> <p></p> <p>Autorizamos a Netlify con Github </p> <p></p> <p>Y luego debemos seleccionar el proyecto que queramos subir, y si lo hemos hecho bien deberiamos acabar en la siguiente pesta\u00f1a </p> <p></p> <p>Por \u00faltimo terminamos la configuraci\u00f3n del despliegue </p> <p></p> <p>Y comenzar\u00e1 autom\u00e1ticamente el despliegue</p> <p></p> <p>De esta manera lo que hemos conseguido es que todos los <code>commit - push</code> que hagamos en gitHub resulte en un nuevo despliegue en netlify, que es lo conocido como despliegue continuo.</p> <p>Comprobemos esto:</p> <ul> <li>Para esto haremos un cambio en el archivo <code>robots.txt</code> a\u00f1adiendo en disallow /alberto_luque</li> </ul> <p></p> <ul> <li>Tras esto haremos un nuevo <code>commit</code> y <code>push</code>.</li> <li>Y comprobaremos que etos cambios se han visto en Netlify.</li> </ul>"},{"location":"tarea3.5/","title":"Tarea 3.5: Despliegue de una aplicaci\u00f3n Flask (Python)","text":""},{"location":"tarea3.5/#prerequisitos","title":"Prerequisitos","text":"<p>Servidor Debian con los siguientes paquetes instalados:</p> <ul> <li>Nginx</li> <li>Gunicorn</li> <li>Pipenv</li> </ul> <p>Estas instalacioes se podr\u00e1n hacer con <code>sudo apt install &lt;paquete&gt;</code></p>"},{"location":"tarea3.5/#introduccion","title":"Introducci\u00f3n","text":""},{"location":"tarea3.5/#que-es-un-framework","title":"\u00bfQu\u00e9 es un framework?","text":"<p>Un framework es un entorno de desarrollo que normalmente est\u00e1 especializado al lenguaje de programaci\u00f3n que se est\u00e1 usando, en el caso de Python el m\u00e1s conocido es Django pero en nuestro caso usaremos, Flask ya que su curva de aprendizaje no es tan grande y se pueden hacer grandes aplicaciones, por otra parte para PHP tenemos Symphony, y para Ruby est\u00e1 Ruby on Rails.</p>"},{"location":"tarea3.5/#flask","title":"Flask","text":"<p>Hoy en dia hay muchas opciones para hacer aplicaciones web(PHP, JAVA), y en este caso Flask nos permite esto con Python.</p> <p>Flask se dice que es un \"micro\" framework ya que en un principio solo se instalan las funcionalidades b\u00e1sicas para crear una p\u00e1gina web, pero que se pueden a\u00f1adir con plugins para Flask.</p> <p>Flask utiliza el patron MVC (modelo - vista - controlador) este patron diferencia la base de datos o datos (modelo), del html (vista) y JavaScript y peticiones a BBDD (controlador).</p>"},{"location":"tarea3.5/#gunicorn","title":"Gunicorn","text":"<p>Cuando se implenta una aplicaci\u00f3n web basada en Python, se tienen estas tres piezas:</p> <ul> <li>Servidor web(Nginx, Apache).</li> <li>Servidor de aplicaciones WSGI(Gunicorn, uWSGI, mod_wsgi, Waitress).</li> <li>Aplicaci\u00f3n Web(Django, Flask, Pyramid, FastAPI).</li> </ul> <p>Los servidores web procesan y distribuyen las peticiones de navegadores y clientes, WSGI(Web Server Gateway Interface), proporcionan un conjunto de reglas y para el comportamiento y comunicaci\u00f3n entre el servidor y las aplicaciones.</p> <p>Gunicorn(Green Unicorn) es un servidor WSGI, que se encuentra entre el servidor web y su aplicaci\u00f3n web. Este se encarga entre la comunicaci\u00f3n entre estos traduciendo ordenes y peticiones.</p>"},{"location":"tarea3.5/#gestor-de-paquetes-pip","title":"Gestor de paquetes <code>pip</code>","text":"<p><code>pip</code> es el comando para instalar paquetes de Python, automatizando la conexi\u00f3n al sitio https://pypi.org/, descarga y la compilaci\u00f3n del m\u00f3dulo.</p>"},{"location":"tarea3.5/#entornos-virtuales-en-python","title":"Entornos virtuales en Python","text":"<p>Un entorno virtual te permite tener m\u00faltiples instancias del interprete de Python, cada una configurada de diferente manera con distintos paquetes.</p> <p>De esta manera nos permite instalar paquetes de forma local en un entorno con <code>pip</code>.</p>"},{"location":"tarea3.5/#pipenv","title":"Pipenv","text":"<p>Este permite crear y mantener un entorno virtual para tus proyectos, agregando/borrando paquetes desde Pipfile; generando el archivo <code>Pipfile.lock</code>.</p>"},{"location":"tarea3.5/#procedimiento-completo-para-el-despliegue","title":"Procedimiento completo para el Despliegue","text":"<ol> <li>Instalamos el gestor de paquetes de Python</li> </ol> <ol> <li>Instalamos el paquete <code>pipenv</code> para gestionar los entornos virtuales:</li> </ol> <ol> <li>Y comprobamos que est\u00e1 isntalado correctamente mostrando su versi\u00f3n:</li> </ol> <p><code>pipenv --version</code></p> <ol> <li>Creamos el directorio en el que almacenaremos nuestro proyecto:</li> </ol> <p></p> <ol> <li>Al crearlo con <code>sudo</code>, los permisos pertenecen a root:</li> </ol> <p></p> <ol> <li>Hay que cambiarlo para que el due\u00f1o sea nuestro usuario (<code>nombre-debian</code>) y pertenezca al grupo <code>www-data</code>, el usuario usado por defecto por el servidor web para correr:</li> </ol> <p></p> <ol> <li>Estableceremos los permisos adecuados a este directorio, para que pueda ser le\u00eddo todo el mundo:</li> </ol> <p></p> <ol> <li>Dentro del directorio de nuestra aplicaci\u00f3n, creamos un archivo oculto <code>.env</code> que contendr\u00e1 la variables de entorno necesarias:</li> </ol> <p></p> <ol> <li>Editamos el archivo y a\u00f1adimos las variables, indicando cu\u00e1l es el archivo <code>.py</code> de la aplicaci\u00f3n y el entorno, que en nuestro caso ser\u00e1 producci\u00f3n:</li> </ol> <p></p> <ol> <li>Inicamos ahora nuestro entrono virtual. <code>Pipenv</code> cargar\u00e1 las variables de entorno desde el fichero <code>.env</code> de forma autom\u00e1tica:</li> </ol> <p></p> <ol> <li>Usamos <code>pipenv</code> para instalar las dependencias necesarias para nuestro proyecto:</li> </ol> <p></p> <ol> <li>Ahora para comprobar que nuestra aplicaci\u00f3n funciona adecuadamente, crearemos la aplicaci\u00f3n m\u00e1s secilla con Flask. El archivo con la aplicaci\u00f3n ser\u00e1 <code>application.py</code> y la que se encargar\u00e1 de iniciarla ser\u00e1 <code>wsgi.py</code>:</li> </ol> <p> </p> <ol> <li>Ahora comprobamos nuestra aplicaci\u00f3n a modo de comprobaci\u00f3n con el servidor Flask integrado.</li> </ol> <p></p> <ol> <li>Ahora podremos desde nuestra m\u00e1quina anfitriona, introducir <code>http://IP-maq-virtual:5000</code>:</li> </ol> <p></p>"},{"location":"tarea3.5/#comprobacion-de-gunicorn","title":"Comprobaci\u00f3n de Gunicorn","text":"<ol> <li>Comprobemos ahora que funciona Gunicorn funciona. Si ha funcionado con Flask con el siguiente comando podemos comprobar que funciona con Gunicorn.</li> </ol> <ol> <li>Debemos comprobar con el comando <code>which gunicorn</code> cual es el path desde el que se ejecuta gunicorn:</li> </ol> <ol> <li>Como ya tenemos Nginx lo iniciamos:</li> </ol> <ol> <li>Ya fuera de nuestro entorno virtual, crearemos un archivo para que systemd corra Gunicorn como un servicio del sistema m\u00e1s:</li> </ol> <ol> <li>Ahora habilitamos e iniciamos el servicio</li> </ol> <p><code>systemctl enable nombre_servicio</code> <code>systemctl start nombre_servicio</code></p> <ol> <li>Creamos un archivo con el nombre de nuestra aplicaci\u00f3n en el que se establecer\u00e1 la configuraci\u00f3n del sitio, por esto se encontrar\u00e1 en <code>/etc/nginx/sites-available/nombre_aplicacion</code>.</li> </ol> <p></p> <ol> <li>Ahora deberemos crear un enlace simb\u00f3lico a <code>sites-enabled</code>:</li> </ol> <p></p> <ol> <li>Comprobamos la configuraci\u00f3n de NGINX y comprobamos que el estado sea activo:</li> </ol> <p></p> <ol> <li> <p>Ahora accederemos a nuestra p\u00e1gina est\u00e1 siendo servida por Gunicorn y Nginx, por lo que necesitaremos editar el archivo <code>/etc/hosts</code> de nuestra m\u00e1quina para que asocie la IP de la m\u00e1quina a nuestro <code>server_name</code>:</p> </li> <li> <p>Por \u00faltimo deberemos comprobar que todo ha ido bien accediendo a nuestra p\u00e1gina con <code>http://nombre_aplicacion</code> o <code>http://www.nombre_aplicacion</code>:</p> </li> </ol>"},{"location":"tarea4.1/","title":"Servidor DNS","text":""},{"location":"tarea4.1/#que-es-un-servidor-dns","title":"Que es un servidor DNS","text":"<pre><code>Un servidor DNS es un servidor que se encarga de traducir las peticiones en texto plano a una direcci\u00f3n ip.\n</code></pre>"},{"location":"tarea4.1/#instalacion-de-servidor-dns","title":"Instalaci\u00f3n de servidor DNS","text":"<p>Bind es el est\u00e1ndar para servidores DNS. Es una herramienta de software libre que se puede usar en la mayoria de plataformas Unix y Linux conocido como named (name daemon). Bind9 es la versi\u00f3n recomendada y es la que usaremos. Lo instalaremos de la siguiente manera:</p> <p><code>sudo apt-get install bind9 bind9utils bind9-doc</code></p>"},{"location":"tarea4.1/#configuracion-del-servidor","title":"Configuraci\u00f3n del servidor","text":"<p>Puesto que solo usaremos <code>IPV4</code>, lo configuraremos en el directorio <code>/etc/default</code>; y para indicarle qeu s\u00f3lo use IPv4, modificamos la l\u00ednea <code>OPTIONS = \"-u bind -4\"</code>.</p> <p>El archivo de configuraci\u00f3n principal <code>named.conf</code> de Bind est\u00e1 en el directorio: <code>/etc/bind</code></p> <p>Veremos esto:</p> <p></p> <p>Este archivo sirve para agrupar los archivos de configuraci\u00f3n que usaremos. </p>"},{"location":"tarea4.1/#configuracion-namedconfoptions","title":"Configuraci\u00f3n named.conf.options","text":"<p>Es una buena pr\u00e1ctica realizar copias de seguridad a los archivos de configuraci\u00f3n cuando van a ser modificados.</p> <p><code>sudo cp /etc/bind/named.conf.options /etc/bind/named.conf.options.backup</code></p> <p>Ahora editaremos el archivo <code>named.conf.options</code> e incluiremos lo siguiente:</p> <ul> <li>Por motivos de seguiridad a\u00f1adiremos una lista de acceso para que s\u00f3lo puedan hacer consultas recursivas aquellos hosts que permitamos.     En nuestro caso, los confiables son los de la red 192.168.X.0/24 donde la 'X' depender\u00e1 de la red de casa. De esta forma tendremos que a\u00f1adir algo as\u00ed.</li> </ul> <p></p> <p>Esta inicialmente configurado para ser un servidor DNS cach\u00e9. Y se guardar\u00e1n las zonas en <code>/var/cache/bind</code></p> <ul> <li>Solo se permiten consultas recursivas a los hosts que hemos decidido en la lista de acceso.</li> <li>No permitir transferencias de zona a nadie.</li> <li>Configurar el servidor para que escuche las consultas DNS en el puerto 53. Se debe colocar la IP de la indterfaz de Debian.</li> <li>Permitir las consultas recursivas, ya que en el primer punto ya le hemos dichos que s\u00f3lo puedan hacerlas los hosts de la ACL.</li> <li>Debemos comentar la l\u00ednea en la que pone <code>listen-on-v6 {any};</code> puesto que no vamos a responder consultar IPv6.</li> </ul> <p>Podemos comprobar si la configuracion es correcta con el comando <code>sudo named-checkconf</code>.</p> <p>Reiniciamos y comprobamos el servidor.</p> <p></p>"},{"location":"tarea4.1/#configuracion-namedconflocal","title":"Configuraci\u00f3n named.conf.local","text":"<p>En este archvivo configuraremos aspectos relativos a nuestras zonas. Vamos a declarar la zona \"deaw.es\". Por ahora indicaremos que el servidor DNS es maestro para esta zona.</p> <p></p>"},{"location":"tarea4.1/#creacion-del-archivo-de-zona","title":"Creaci\u00f3n del archivo de zona","text":""},{"location":"tarea_ampliacion/","title":"Configuraci\u00f3n de un servidor Nginx con Hosts Virtuales y directorios de usuario","text":"<p>En esta pr\u00e1ctica vamos a vamos a crear varios hosts virtuales para alojar m\u00faltiple sitios web y que cada usuario de la m\u00e1quina Debian maodifique su sitio a trav\u00e9s de su carpeta personal, esto se consigue haciendo que cada host virtual apunte al directorio public_html.</p>"},{"location":"tarea_ampliacion/#instalacion-de-nginx","title":"Instalaci\u00f3n de Nginx","text":"<ul> <li>Tener un entorno Debian.</li> <li>Instalar Nginx.</li> <li>Usar SSH para manipular el servidor.</li> </ul>"},{"location":"tarea_ampliacion/#creacion-de-usuarios-del-sistema","title":"Creaci\u00f3n de usuarios del sistema:","text":"<ul> <li> <p>Creaci\u00f3n de usuarios.</p> <ul> <li>Crea dos usuarios (usuario1 y usuario2).  </li> </ul> <p><code>sudo adduser usuario1</code> <code>sudo adduser usuario2</code>.</p> <ul> <li>Asignaci\u00f3n de contrase\u00f1as</li> </ul> </li> </ul>"}]}